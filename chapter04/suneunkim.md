## 04장 - 서버 사이드 렌더링

### 4.1 서버 사이드 렌더링이란?

### 4.1.1 싱글 페이지 애플리케이션의 세상

먼저 서버 사이드 렌더링 애플리케이션과 반대되는 개념인 싱글 페이지 애플리케이션을 먼저 살펴보자

SPA란 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식을 의미한다. 최초에 첫 페이지에서 데이터를 모두 불러온 이후에는 페이지 전환을 위한 모든 작업이 자바스크립트와 브라우저의 `history` 메서드로 이뤄진다. 처음 페이지를 불러온 이후에는 서버에서 HTML을 내려받지 않고 하나의 페이지에서 모든 작업을 처리하므로 싱글 페이지 애플리케이션이라고 한다.

SPA의 HTML 코드를 크롬의 소스 보기로 확인하면 `<body />` 내부에 내용이 없다. 이는 사이트 렌더링에 필요한 `<body />` 내부의 내용을 모두 자바스크립트 코드로 삽입한 이후에 렌더링하기 때문이다. 페이지 전환 시에도 새로운 HTML 페이지를 요청하는게 아니라 다음 페이지에서 필요한 정보만 JS로 HTTP 요청 등으로 가져온 다음에 `<body />` 내부에 DOM을 추가, 수정, 삭제하는 방법으로 페이지가 전환된다.

즉, 최초에 서버에서 최소한의 데이터를 불러온 이후부터는 이미 가지고 있는 JS 리소스와 브라우저 API 기반으로 모든 작동이 이뤄진다. 이러한 작동 방식은 최초에 로딩해야 할 JS 리소스가 커지는 단점이 있지만 한번 로딩된 이후에는 서버를 거쳐 리소스를 받아올 일이 적어지기 때문에 사용자에게 훌륭한 UI/UX를 제공한다는 장점이 있다.

SPA가 부상하게 된 이유들은 무엇들이 있을까? (책 내용이 아닌 개인적인 필기)

1. **자바스크립트의 발전**: 초기 웹 개발에서 자바스크립트는 주로 단순한 클라이언트 측 상호작용에 사용되었습니다. 하지만 시간이 지나면서 자바스크립트는 더욱 강력하고 다양한 기능을 수행할 수 있는 언어로 발전했습니다. 이는 SPA의 발전을 가능하게 했습니다.
2. **리액트, 앵귤러, 뷰 등의 등장**: 이러한 프론트엔드 프레임워크 및 라이브러리들은 자바스크립트의 사용을 간소화하고, 상호작용이 풍부한 웹 애플리케이션 개발을 촉진했습니다. 이들은 데이터와 UI 간의 동적 상호작용을 쉽게 만들어 사용자 경험을 개선했습니다.
3. **사용자 경험 개선**: SPA는 페이지 전환 없이 애플리케이션 내에서 매끄러운 사용자 경험을 제공합니다. 이는 모바일 앱과 유사한 사용자 경험을 웹에서도 가능하게 했습니다.
4. **성능 향상**: 전통적인 MPA(멀티 페이지 애플리케이션)와 달리 SPA는 초기 로딩 후 필요한 데이터만 비동기적으로 로드하여 빠른 상호작용을 제공합니다.
5. **모바일 인터넷의 확산**: 모바일 기기 사용의 증가와 함께 앱과 같은 풍부한 인터랙티브 경험을 제공하는 웹 애플리케이션이 필요해졌습니다. SPA는 이러한 요구에 잘 부합합니다.
6. **웹 애플리케이션의 복잡성 증가**: 현대 웹 애플리케이션은 복잡하고, 상호작용이 많으며, 실시간 업데이트를 요구합니다. SPA 프레임워크와 라이브러리는 이러한 복잡한 애플리케이션을 효과적으로 구축할 수 있는 수단을 제공합니다.
7. **개발 효율성**: SPA는 프론트엔드와 백엔드를 분리하는 방식을 채택함으로써 개발 프로세스를 간소화하고, 효율성을 높일 수 있습니다.

### 4.1.2 서버 사이드 렌더링이란?

최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식이다.

웹 애플리케이션은 다양한 작업을 처리하고 있고 더불어 자바스크립트의 리소스 크기가 점점 커져서 SPA의 한계를 개선하고자 서버에서 페이지를 렌더링해 제공하는 기존 방식의 웹 개발이 다시금 떠오르고 있다.

웹페이지 렌더링의 책임을 클라이언트의 자바스크립트가 하느냐 서버에서 하느냐가 중요한 차이이다. 클라이언트의 렌더링은 사용자 기기의 성능에 영향을 받지만 서버 사이드 렌더링은 비교적 안정적인 렌더링이 가능하다.

SSR의 장점

1. 최초 페이지 진입이 비교적 빠르다. 특히 최초에 사용자에게 보여줘야 할 화면에 표시할 정보가 외부 API 호출에 많이 의지해야 한다는 가정을 해보자. SPA에선 페이지 진입 → js 리소스 다운로드 → HTTP 요청 → 결과를 렌더링의 과정을 거친다. 이런 작업이 서버에서 이뤄지면 한결 빠르게 렌더링될 수 있다. 서버에서 HTTP 요청을 수행하는 것이 더 빠르고 서버에서 HTML 문자열을 미리 그려서 내려주는 것이 클라이언트에서 기존 HTML에 삽입하는 것 보다 더 빠르기 때문이다.
2. 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다. 검색 엔진 로봇이 HTML을 다운로드하고 js 코드를 실행하지 않는다(무조건은 아님)
3. 누적 레이아웃 이동이 적다. 누적 레이아웃 이동이란 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥거리는 것처럼 보이는 사용자 경험을 말한다. SPA는 페이지 콘텐츠가 API 요청에 의존하고 응답 속도가 제각각이며 이를 적절히 처리해두지 않으면 누적 레이아웃 이동 문제가 발생할 수 있다.
4. 사용자의 디바이스 성능에 비교적 자유롭다. js 리소스 실행은 사용자의 디바이스에서만 실행되므로 절대적으로 사용자의 디바이스 성능에 의존적이다.
5. 보안에 좀 더 안전하다. 민감한 작업을 서버에서 수행하고 그 결과만 브라우저에 제공할 수 있기 때문이다.

SSR 단점

1. 소스코드를 작성할 때 항상 서버를 고려해야 한다. 브라우저 전역 객체인 window 또는 sessionStorage와 같은 코드는 서버에서 실행 된다면 에러가 생긴다. 서버에서 실행될 가능성이 있는 코드인지 고려해야한다.
2. 적절한 서버가 구축돼 있어야 한다. 서버를 구축하는 일은 쉽지 않고 고려할 점이 많다.
3. 서비스 지연에 따른 문제. 무언가 느린 작업이 있을 때 SPA는 ‘로딩 중’과 같이 작업이 진행 중임을 안내할 수 있다. SSR은 렌더링 작업이 끝나기까지는 사용자에게 정보를 제공할 수 없다.

### 4.3 Next.js 톺아보기

Next.js는 리액트 기반 서버 사이드 렌더링 프레임워크이다.

### 4.3.2 Next.js 시작하기

`pacakge.json`:

- 프로젝트 구동에 필요한 모든 명령어 및 의존성이 포함되어있다

`next.config.js`:

- Next.js 프로젝트의 환경 설정을 담당한다.

`pages/_app.tsx`:

- 애플리케이션의 전체 페이지의 시작점으로 웹 애플리케이션에서 공통으로 설정해야 하는 것들을 여기에서 실행할 수 있다
- 에러 바운더리를 사용해 애플리케이션 전역에서 발생하는 에러 처리
- reset.css 같은 전역 CSS 선언
- 모든 페이지에 공통으로 사용 또는 제공해야 하는 데이터 제공

`pages/_document.tsx`

- 애플리케이션의 HTML을 초기화하는 곳이다.

**`_app.tsx`과의 차이점:**

- `<html>`이나 `<body>`에 DOM 속성을 추가하고 싶다면 `_document.tsx`을 사용한다.
- `_app.tsx`는 렌더링이나 라우팅에 따라 서버나 클라이언트에서 실행될 수 있지만 \_document는 **무조건 서버에서 실행**된다. 따라서 이벤트 핸들러를 추가하는 것은 불가능하다.
- `_app.tsx`는 Next.js를 초기화하는 파일로, Next.js 설정과 관련된 코드를 모아두는 곳이며, 경우에 따라 서버와 클라이언트 모두에서 렌더링될 수 있다/
- `_document.tsx`는 Next.js로 만드는 웹사이트의 뼈대가 되는 HTML 설정과 관련된 코드를 추가하는 곳이며 반드시 서버에서만 렌더링된다.

### 4.3.3 Data Fetching

Next.js에서는 서버 사이드 렌더링 지원을 위한 데이터 불러오기 전략이 있다. 이를 활용하면 서버에서 미리 필요한 페이지를 만들어서 제공하거나, 요청이 있을 때마다 서버에서 데이터를 조회해서 미리 페이지를 만들어서 제공할 수 있다.

1. `getStaticPaths` 와 `getStaticProps`
   - 블로그, 게시판과 같이 사용자와 관계없이 정적으로 결정된 페이지를 보여주고자 할 때 사용하는 함수
2. `getServerSideProps`
   - 서버에서 실행되는 함수이며 해당 함수가 있다면 무조건 페이지 진입 전에 이 함수를 실행한다. 응답값에 따라 페이지의 루트 컴포넌트에 props를 반환할 수도, 혹은 다른 페이지로 리다이렉트시킬 수도 있다.
