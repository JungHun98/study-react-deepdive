# 5장 리액트와 상태관리 라이브러리

## 상태 관리는 왜 필요한가?

상태관리에 대한 이야기를 하기 앞서 `상태` 란 무엇일까?

웹 애플리케이션에서 상태로 분류될 수 있는 것들은 대표적으로 다음과 같은 것이 있다.

- UI: 상호 작용이 가능한 모든 요소의 현재값을 의미한다. 다크/라이트 모드, 각종 input, 알림창의 노출 여부 등 많은 종류의 상태가 존재한다.
- URL: 브라우저에 의해 관리되고 있는 상태 값이다. 이 상태는 사용자의 라우팅에 따라 변경된다.
- 폼(form): 로딩 중, 제출 여부, 접근 가능 여부, 유요한 값인지 등 모두가 상태로 관리된다.
- 서버에서 가져온 값: 클라이언트에서 서버로 요청을 통해 가져온 값 역시 상태로 볼 수 있으며, 대표적으로 API 요청이 있다.

웹 서비스에서 점차 다양한 기능이 제공됨에 따라 웹 내부에서 관리해야 할 상태도 점차 비례해서 증가하고 있다. 단순히 서버에서 요청 받은 내용을 보여주기만 하는 시대에는 상태라고 구분 지을 요소가 없었지만 이제는 상태를 효과적으로 관리하는 방법을 계속해서 고민해야 한다.

상태를 어디서 둘 것 인지, 상태가 유효한 범위는 어디까지인지, 상태 변화에 따라 변경되어야 하는 요소들은 이 상태 변화를 어떻게 감지할 것인지 등 상태관리는 복잡하고 다양한 경우를 고려해야 한다. 이러한 상태를 효율적으로 관리하고 상태가 필요한 쪽에서는 빠르게 반응할 수 있는 모델에 대한 고민이 본격적으로 시작되었다.

### 리액트 상태 관리의 역사

리액트는 프레임워크가 아니라 단순히 UI를 만들기 위한 라이브러리일 뿐이라 개발자에 따라 시간에 따라 상태 관리 방법에 차이가 있었다.

**Flux 패턴의 등장**

순수 리액트에서 할 수 있는 전역 상태 관리 수단이라고 한다면 Context API를 떠올릴 수 있다. 이전에는 리덕스가 등장하기 이전까지 리액트에서 유명한 상태 관리 라이브러리는 존재하지 않았다.

그러던 중 2014년 경 Flux 패턴를 기반으로 한 상태관리 라이브러리를 발표한다.

Flux 패턴이란 무엇일까?

Flux 패턴이 등장하기 이전에는 웹 애플리케이션이 비대해지고 상태도 많아짐에 따라 상태 변경의 원인을 추적하고 이해하기 매우 어려운 상황이었다. 페이스북 팀은 이러한 문제의 원인을 양방향 데이터 바인등으로 생각했다. 기존 MVC 모델의 웹 애플리케이션에서는 뷰가 모델은 변경할 수 있으며, 모델 역시 뷰를 변경할 수 있었다. 코드를 작성하는 입장에서는 간다할 수 있지만 코드의 양이 많아지고 변경 시나리오가 복잡해질수록 관리가 어려워진다.

따라서 페이스북 팀은 단방향으로 데이터 흐름을 변경하는 Flux 패턴을 제안했다. Flux 패턴은 크게 네 가지의 데이터 흐름이 존재한다

- action: 어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터를 의미한다. 액션 타입과 데이터를 각각 정의해 이를 디스패처로 보낸다.
- dispatcher: 액션을 스토어에 보내는 역할을 한다. 콜백 함수 형태로 앞서 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.
- 스토어: 실제 상태에 따른 값, 상태를 변경할 수 있는 메서드를 가지고 있는 객체다. 액션의 타입에 따라 어떻게 상태를 변경할지 정의돼 있다.
- 뷰: 리액트의 컴포넌트에 해당하는 부분으로, 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다. 뷰에서 스토어의 상태를 업데이트하고 싶은 경우 뷰에서 액션을 호출하여 상태를 변경한다.

리액트는 대표적인 단방향 데이터 바인딩을 기반으로 한 라이브러리라 단방향 흐름을 정의하는 Flux 패턴과 매우 궁합이 잘 맞았다. 이와 동시에 Flux 패턴을 따르는 다양한 라이브러리들이 만들어졌다.

**시장 지배자 리덕스의 등장**

리액트와 단방향 데이터 흐름이 점점 두각을 드러내던 와중 등장한 것이 리덕스이다.

리덕스는 하나의 상태 객체를 **스토어**에 저장해 두고, 이 객체를 **업데이트하는 작업을 디스패치**해 업데이트를 수행한다. 이러한 작업은 웹 애플리케이션 상태에 대한 완전히 새로운 복사본을 반환한 다음, 새롭게 만들어진 상태를 전파하는 **reducer함수**로 발생시킨다. 

이러한 리덕스의 등장은 하나의 글로벌 상태 객체를 통해 하위 컴포넌트에 props drilling 없이 전파할 수 있었고, 스토어가 필요한 컴포넌트라면 단지 connect만 사용해 스토어에 접근할 수 있었다. 리덕스는 지금까지도 리액트 상태 관리에서 아주 중요한 축이다.

**Context API와 useContext**

리액트가 탄생한 뒤에도 상태를 어떻게 적절하게 주입해야 하는지에 대한 고민은 계속 이어져왔다. props drilling, 리덕스를 사용하면서 단순히 상태를 참조하고 싶을 뿐임에도 action, dispatch, reducer, selector와 같은 추가 작업이 필요했다. 이는 번거로움을 넘어 컴포넌트 설계 단계에서 커다란 제약으로 작용했다.

이 문제를 해결하기 위해 리액트는 Context API를 출시했다. Context를 사용하면 Provider 컴포넌트에 주입된 상태를 깊이에 상관없이 곧 바로 전달 할 수 있게됐다.

**훅의** **탄생, React Query와 SWR**

Context API 출시 이후 리액트에 함수형 컴포넌트에 사용할 수 있는 다양한 훅 API를 추가했다. 훅을 통해 클래스형 컴포넌트보다 훨씬 간결하고 직관적으로 상태를 관리할 수 있게 됐다. 이렇나 훅과 state의 등장으로 새로운 방식의 상태 관리가 등장하는데 ReactQuery와 SWR이다.

두 라이브러리는 모두 API 요청인 fetch를 관리하는데 특화된 라이브러리지만, API 호출에 대한 상태를 관리하고 있기 때문에 무상태인 HTTP 요청에 특화된 상태 관리 라이브러리라 볼 수 있다.

**Recoil, Zustand, Jotai, Valtio에 이르기까지**

훅이라는 새로운 패러다임의 등장에 따라, 훅을 활용해 상태를 가져오거나 관리할 수 있는 다양한 라이브러리가 등장하게 된다. 기존 리덕스와의 차이점은 훅을 활용해 작은 크기의 상태를 효율적으로 관리한다는 것이다. 

개발자가 원하는 만큼의 상태를 지역적으로 관리하는 것을 가능하게 만들었고, 훅을 지원함으로써 함수형 컴포넌트에서 손쉽게 사용할 수 있다는 장점 또한 가지고 있다. 

## 리액트 훅으로 시작하는 상태관리

비교적 오랜 기간 리액트 생태계에서는 리액트 애플리케이션의 상태 관리를 위해 리덕스에 의존했다. 현재는 Context API, useReducer, useState의 등장으로 컴포넌트에 걸쳐서 재사용하거나 컴포넌트 내부에 걸쳐서 상태를 관리할 수 있는 방법들이 점차 등장해 상태 관리에 대한 선택지가 넓어지고 있다.

### useState, useReducer

상태 관리 훅의 등장으로 리액트에서는 여러 컴포넌트에 걸쳐 손쉽게 동일한 인터페이스의 상태를 생성하고 관리할 수 있게 됐다.

또한 개발자가 상태에 관련한 커스텀 훅을 만들어서 동일한 로직으로 상태를 관리하는 컴포넌트에 재사용까지 가능하다. 나아가 상태를 변경할 수 있는 시나리오가 다양해지고 상태의 구조가 복잡해 진다면 훅으로 코드를 격리해 제공할 수 있단느 장점이 더욱 크게 드러날 것이다.

하지만 useState, useReducer 만으로 상태 관리의 모든 문제를 해결해 주지는 않는다. 같은 로직을 사용하지만 컴포넌트 각각에 상태가 존재하기 때문에 상태 변경에 따른 일괄적인 처리가 불가능하다는 단점이 있다. 결국 부모 컴포넌트의 상태를 자식 컴포넌트로 전달해주는 방법을 생각해 볼 수 있고, 이는 컴포넌트 구조 변경이 불가피하다.

### useState 상태를 바깥으로 분리하기

useState의 한계는 명확하다. 리액트에서 지역 상태로 생성되기 때문에 해당 컴포넌트에서만 사용할 수 있다는 단점이 있다. 그렇다고 해서 상태 값을 자바스크립트 스코프에서 관리하게 된다면 컴포넌트의 리렌더링을 유발 할 수 없기에 상태에 따른 렌더링을 할 수 없다.

즉, 업데이트되는 값을 가져오려면 상태 업데이트 기능 뿐 아니라 컴포넌트에 변경된 상태 값을 반영시키기 위한 리렌더링이 필요하다. 함수형 컴포넌트에서 리렌더링이 발생하려면 다음과 같은 작업 중 하나가 일어나야 한다.

- 상태 관리 훅의 두번째 반환값인 함수 실행
- 부모 함수 컴포넌트의 리렌더링

리렌더링을 유발하기 위해 컴포넌트 바깥에 정의된 상태를 업데이트 하는 함수에서 변경된 상태를 반환받고, 그 상태를 인수로 set함수를 호출하는 방법으로 리렌더링을 유발할 수 있을 것이다. 하지만 이 방법은 보기에도 비효율적이며 문제점도 가지고 있다. 동일한 상태와 업데이트 함수를 사용함에도 불구하고 useState가 존재하는 구조가 문제이다.

또 다른 문제는 같은 상태값을 참조하는 컴포넌트의 리렌더링이 변경시에 자동으로 이뤄지지 않는다는 점이다. 즉, 컴포넌트에서는 상태 변화에 따른 리렌더링을 일으킬 무언가가 없기 때문에 특정 이벤트가 발생하지 않는 한 리렌더링을 할 수 없다. 함수 외부에서 상태를 참조하고 이를 통해 렌더링까지 자연스럽게 일어나려면 다음과 같은 조건을 만족해야 한다.

1. 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 한다.
2. 컴포넌트는 외부 상태의 변화를 감지할 수 있어야 하며, 업데이트 작업마다 리렌더링이 일어나서 컴포넌트를 최신 상태 값 기준으로 렌더링 해야한다. 상태를 참조하는 모든 컴포넌트가 동일하게 수행해야한다.
3. 상태가 객체인 경우, 컴포넌트가 참조하지 않는 값이 변경될 경우 리렌더링을 유발해서는 안된다.

옵저버 패턴을 활용해서 이와 같은 상태관리 객체를 만들 수 있다. 하지만 관리하는 상태가 객체인 경우 객체 내부의 값이 일부만 변경되더라도 해당 스토어를 참조하는 컴포넌트는 반드시 리렌더링이 발생하게 된다. 따라서 이에 대한 별도 처리도 필요하다.

### useState와 Context 같이 사용하기

전역에 별도 스토어를 구현한다면 반드시 하나의 스토어만 가지게 된다. 동일한 타입으로 여러개의 스토어를 만들면 어떨까? 스토어가 필요할 때마다 생성해야 하며, 훅 역시 스토어에 의존적으므로 스토의 개수만큼 훅의 개수 역시 늘어나게 된다.

이 문제를 해결하기 좋은 방법은 리액트의 Context다. Context를 활용해 해당 스토어를 하위 컴포넌트에 주입한다면 컴포넌트에서는 자신이 주입된 스토어에 대해서만 접근할 수 있다.

현재 리액트 생태계에는 많은 상태 관리 라이브러리가 존재하는데 이들이 동작하는 방식은 다음과 같이 요약할 수 있다.

1. useState, useReducer가 가지고 있는 한계인 컴포넌트 내부에서만 사용할 수 있는 지역 상태라는 점을 극복하기 위해 외부 어딘가에 상태를 둔다
2. 이 외부의 상태 변경을 각자의 방식으로 감지해 컴포넌트에 리렌더링을 유발한다.

### 상태관리 라이브러리 Recoil, Jotai, Zustand

세 상태 관리 라이브러리가 지향하는 목적은 무엇이고 라이브러리 내부에서 어떻게 상태를 관리하며, 상태를 어떻게 컴포넌트로 전파하는지 알아보자

**Recoil**

Recoil은 리액트에서 훅의 개념으로 상태 관리를 시작한 최초의 라이브러리이며, Atom을 선보이기도 했다. 

- RecoilRoot
    - 리코일을 사용하기 위해서는 이 API를 애플리케이션의 최상단에 선언해 둬야 한다.
    - 이 API에서 리코일에서 생성되는 상태값을 저장하기 위한 스토어를 생성하는 것을 확인할 수 있다. Context의 스토어에 상태값이 저장된다.
    - 스토어는 ID, 상태 값에 접근(getter, setter) 할 수 있는 함수 등으로 이뤄져있다. 이 함수는 RecoliRoot로 감싸져 있어야 접근이 가능하다.
    - 상태 값을 변경하는 setter에는 구독중인 컴포넌트에 변경 사실을 알리는 notify 함수가 존재한다.
- atom
    - atom은 상태를 나타내는 리코일의 최소 단위다.
    - atom은 key값을 필수로 가지며, 이 키는 다른 atom과 구별하는 식별자가 되는 유일한 값이다.
    - atom의 값을 컴포넌트에서 읽어오고 이 값의 변화에 따라 컴포넌트를 리렌더링할 수 있다.
- useRecoilValue
    - atom의 값을 읽어올 수 있다.
    - 리코일이 가지고 있는 상태값을 가지고 있는 클래스를 반환하는 함수이고 이전 상태값과 같다면 리렌더링을 생략하기 위해 내부적으로 useRef를 이용해 이전 값을 기억하고 있다.
    - 그리고 useEffect를 통해 상태가 변경되었을 때 상제로 렌더링을 일으킨다.
- useRecoilState
    - useState와 굉장이 유사한 구조로 만들어져 있다.
    - 상태를 읽고 변경할 수 있는 함수를 사용할 수 있다.

리코일은 다양한 비동기 작업을 지원하는 API를 제공하고 있기 때문에 리덕스와 갈리 추가적인 미들웨어를 사용하지 않더라도 비동기 작업을 수월하게 처리할 수 있다.

**Jotai**

조타이는 리코일의 atom모델에 영감을 받아 만들어진 상태관리 라이브러리이다. 조타이는 최상단의 상태값을 애플리케이션에 내려주는 방식이 아니라, 작은 단위의 상태를 위로 전파할 수 있는 구조를 취하고 있다.

이는 Context의 단점인 불필요한 리렌더링을 방지 하기 위해 설계되었으며, 개발자들이 메모이제이션을 하거나 최적화 과정을 거치지 않아도 리렌더링이 발생되지 않도록 설계되어 있다.

- atom
    - 조타이 역시 리코일과 동일한 개념으로 atom이 존재한다.
    - 다른 점은 atom하나만으로 상태를 만들 수도 있고, 이에 파생된 상태를 만들 수도 있다.
    - 각 atom을 만들 때 key를 넘겨주지 않아도 된다.
    - atom에서는 따로 상태를 저장하고 있지 않다.
- useAtomValue
    - 조타이는 atom을 스토어에서 관리하고 있다.
    - 스토어는 atom 객체 그자체를 키로 활용해 값을 저장한다.
    - 그리고 넘겨 받은 객체가 스토어에 저장된 객체와 달라지는 경우 리렌더링을 발생시킨다.
- useAtom
    - useState와 동일한 형태의 배열을 반환한다.
    - atom의 현재값을 나타내는 useAtom Value 훅의 결과를 반환하며, atom을 수정할 수 있는 기능을 제공하는 훅을 반환한다.

조타이가 별도의 문자열 키가 없어도 각 값들을 관리할 수 있는 것은 객체의 참조를 통해 값을 관리하기 때문이다. 그리고 리코일에 비해 간결하게 atom에서 파생된 또다른 atom을 간결하게 생성할 수 있다.

**Zustand**

Zustand는 리덕스에 영감을 받아 만들어졌으며, 중앙 집중형으로 활용해 이 스토어 내부에서 상태를 관리하고 있다.

먼저 Zustand는 특별히 많은 코드를 작성하지 않아도 빠르게 스토어를 만들고 사용할 수 있다. 스토어를 만들고 이것을 사용하기만 하면 되기 때문이다. 간단하고 빠르게 상태를 정의할 수 있어 상태를 관리하는 입장에서 가볍고 편리하다.

각 상태관리 라이브러리가 상태를 관리하는 방식에는 차이가 있겠지만 리렌더링을 만드는 방법은 모두 거의 동일하다.