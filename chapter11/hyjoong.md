# 11장: Next.js 13과 리액트 18

이 장은 Next.js 13과 리액트 18의 새로운 기능을 소개합니다.

<br>

- [11장: Next.js 13과 리액트 18](#11장-nextjs-13과-리액트-18)
  - [11.1 app 디렉터리의 등장](#111-app-디렉터리의-등장)
    - [11.1.1 라우팅](#1111-라우팅)
  - [11.2 리액트 서버 컴포넌트](#112-리액트-서버-컴포넌트)
    - [11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계](#1121-기존-리액트-컴포넌트와-서버-사이드-렌더링의-한계)
    - [11.2.2 서버 컴포넌트란?](#1122-서버-컴포넌트란)
    - [11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이](#1123-서버-사이드-렌더링과-서버-컴포넌트의-차이)
    - [11.2.4 서버 컴포넌트는 어떻게 작동하는가?](#1124-서버-컴포넌트는-어떻게-작동하는가)
  - [11.3 Next.js에서의 리액트 서버 컴포넌트](#113-nextjs에서의-리액트-서버-컴포넌트)
    - [11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitial Props의 삭제](#1131-새로운-fetch-도입과-getserversideprops-getstaticprops-getinitial-props의-삭제)
    - [11.3.2 정적 렌더링과 동적 렌더링](#1132-정적-렌더링과-동적-렌더링)
    - [11.3.3 캐시와 mutating, 그리고 revalidating](#1133-캐시와-mutating-그리고-revalidating)
    - [11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기](#1134-스트리밍을-활용한-점진적인-페이지-불러오기)
  - [11.4 웹팩의 대항마, 터보팩의 등장(beta)](#114-웹팩의-대항마-터보팩의-등장beta)
  - [11.5 서버 액션(alpha)](#115-서버-액션alpha)
    - [11.5.1 form의 action](#1151-form의-action)
    - [11.5.2 input의 submit과 image의 formAction](#1152-input의-submit과-image의-formaction)
    - [11.5.3 startTransition과의 연동](#1153-starttransition과의-연동)
    - [11.5.4 server mutation이 없는 작업](#1154-server-mutation이-없는-작업)
    - [11.5.5 서버 액션 사용 시 주의할 점](#1155-서버-액션-사용-시-주의할-점)
  - [11.6 그 밖의 변화](#116-그-밖의-변화)
  - [11.7 Next.js 13 코드 맛보기](#117-nextjs-13-코드-맛보기)
    - [11.7.1 getServerSideProps와 비슷한 서버 사이드 렌더링 구현해 보기](#1171-getserversideprops와-비슷한-서버-사이드-렌더링-구현해-보기)
    - [11.7.2 getStaticProps와 비슷한 정적인 페이지 렌더링 구현해 보기](#1172-getstaticprops와-비슷한-정적인-페이지-렌더링-구현해-보기)
    - [11.7.3 로딩, 스트리밍, 서스펜스](#1173-로딩-스트리밍-서스펜스)
  - [11.8 정리 및 주의사항](#118-정리-및-주의사항)

<br>

## 11.1 app 디렉터리의 등장

Next.js 버전까지의 페이지 공통레이아웃을 유지할 수 있는 방법은 `_app`이 유일했다. 이 방식은 `_app`에서밖에 할 수 없어 제한적이였다.

이러한 레이아웃의 한계를 극복하기 위해 나온 것이 Next.js의 app 레이아웃 이다.

### 11.1.1 라우팅

Next.js13 부터는 app 디렉터리 내부의 폴더명이 라우팅이 되며, 이 폴더에 포함될 수 있는 파일명은 몇 가지로 제한돼 있다.

#### layout.tsx

페이지의 기본레이아웃을 구성하는 요소로, 폴더에 `layout.tsx`파일이 있으면 하위 폴더 및 주소에 영향을 미친다.
기존에는 \_document.tsx에서만 처리할 수 있었던 `<html/>`이나 `<body/>`에 무언가 추가하는 등의 작업을 하려면 `<HTML/>`이나`<Body/>`, `<Head/>`처럼 Next.js에서 제공하는 태그를 사용해야 했었지만
layout에서는 HTML에서 기본으로 제공하는 `<html/>`등의 태그를 추가하고 수정함으로써 별도로 import하는 번거로움이 사라지고 자연스럽게 코드를 작성할 수 있게 됐다.
<br>

#### not-found.ts

특정 라우팅 하위의 주소를 찾을 수 없는 404페이지를 렌더링할 때 사용된다. 이 컴포넌트는 서버 컴포넌트로 구성한다.

#### loading.ts

리액트 Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 표시할 때 사용할 수 있다.

## 11.2 리액트 서버 컴포넌트

리액트 18에서 새로 도입된 서버 컴포넌트는 서버 사이드 렌더링과 완전히 다른 개념이다.

### 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

기존 리액트의 모든 컴포넌트는 클라이언트에서 작동하며, 브라우저에서 자바스크립트 코드가 처리된다.

리액트로 만들어진 웹 사이트에 방문하면 리액트 실행에 필요한 코드를 다운로드하고 리액트 컴포넌트 트리를 만든 다음, DOM에 렌더링된다.

#### 서버 사이드 렌더링의 경우

미리 서버에서 DOM을 생성하고, 클라이언트는 이렇게 생성된 DOM을 기반으로 하이드레이션을 수행한다. 이후 브라우저에서는 상태를 추적하고, 이벤트 핸들러를 DOM에 추가하고, 응답에 따라 렌더링 트리를 변경하기도 한다.

이러한 구조는 유용해 보이지만, 몇 가지 제한 사항이 있다.

1. JS번들 크기가 0인 컴포넌트를 생성할 수 없다.
2. 백엔드 리소스에 직접 엑세스할 수 없다.
3. 자동 코드 분할(code split)이 불가능하다

- 일반적으로 리액트에서는 lzay를 사용해 구현해야 한다. 그렇기 때문에 일일이 lazy로 감싸는 것을 기억해야 하고, 개발자는 항상 코드 분할을 해도 되는 컴포넌트인지 유념하고 개발해야 하기 때문에 이를 누락하는 경우가 발생할 수 있다.

4. 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.

- 하나의 요청으로 컴포넌트가 렌더링되고, 그 렌더링의 결과로 또 다른 컴포넌트를 렌더링 하는 시나리오가 있다. 이 시나리오는 최초 컴포넌트의 요청과 렌더링이 끝나기 전까지 하위 컴포넌트의 요청과 렌더링이 끝나지 않는다는 큰 단점이 있다. 이에 따라 서버에 요청하는 횟수가 늘어나며, 부모 컴포넌트의 요청과 렌더링이 결정되기 전까지, 부모 컴포넌트의 결과에 의존하는 하위 컴포넌트들의 서버 요청이 지연되고 아직 렌더링될 준비가 되지 않았음을 나타내는 불필요한 렌더링이 발생할 수 있다.

5. 추상화에 드는 비용이 증가한다

### 11.2.2 서버 컴포넌트란?

서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법

서버에서 할 수 있는 일은 서버가 처리하게 두고, 서버가 할 수 없는 나머지 작업은 클라이언트인 부라우저에서 수행된다.
즉, 일부 컴포넌트는 클라이언트에서, 일부 컴포넌트는 서버에서 렌더링되는 것이다.

#### 서버 컴포넌트

- 요청이 오면 그 순간 서버에서 딱 한 번 실행될 뿐이므로 **상태를 가질 수 없다.**
- 렌더링 생명주기를 사용할 수 없다.
- 데이터베이스, 내부 서비스, 파일 시스템 등 서버에만 있는 데이터를 async/await으로 접근할 수 있다.

### 11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이

서버 사이드 렌더링은 페이지를 서버에서 HTML로 전체 렌더링한 후 클라이언트에게 전송하는 과정이다. 그런 다음 클라이언트에서는 서버의 결과를 확인하고 이벤트를 추가하는 등의 작업을 위해 하이드레이션 과정을 거친다.
서버 사이드 렌더링은 초기 상호작용이 불가능하지만 정적 HTML을 빠르게 전달하는 데 초점을 두고 있다. 따라서 초기 HTML이 로드된 후에는 클라이언트에서 JavaScript 코드를 다운로드하고 파싱하며 실행하는 데 비용이 발생한다.

### 11.2.4 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 렌더링 요청을 받는다.
2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화한다.
3. 브라우저가 리액트 컴포넌트 트리를 구성한다.
   <br>

## 11.3 Next.js에서의 리액트 서버 컴포넌트

Next.js 13버전부터 서버 컴포넌트를 도입했다.

### 11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitial Props의 삭제

`/app`경로를 사용하면서 모든 데이터 요청은 웹에서 제공하는 표준 API인 `fetch`를 기반으로 이루어진다.

### 11.3.2 정적 렌더링과 동적 렌더링

이전에는 getStaticProps와 getServerSideProps를 활용하여 정적 및 동적 페이지를 만들었지만, Next.js 앱 라우터에서는 이제 다음과 같은 코드를 사용하여 작성할 수 있다.

```javascript
// 기존 SSG 방식을 fetch를 사용해서 구현
const res = await fetch(`https://~~~`);
const data = await res.json();

// 기존 SSR 방식을 fetch를 사용해서 구현
const res = await fetch(`https://~~`, {
  cache: "no-store",
});
const data = await res.json();
```

이 밖에도 함수 내부에서 Next.js가 제공하는 `next/headers`나 `next/cookie`같은 헤더 정보와 쿠키 정보를 불러오는 함수를 사용하게 된다면 해당 함수는 동적인 연산을 바탕으로 결과를 반환하는 것으로 인식해 정적 렌더링 대상에서 제외된다.

동적 주소지만 특정 주소에 대해서 캐싱하고 싶은 경우 `getStaticPaths`방식을 사용하려면 `generateStaticParams`를 사용하면 된다.

```javascript
export async function generateStaticParams() {
  return [{ id: "1" }, { id: "2" }, { id: "3" }];
}
```

### 11.3.3 캐시와 mutating, 그리고 revalidating

fetch에 revalidate 속성 값을 정의하여 캐시 주기를 설정할 수 있다.

만약 아래처럼 revalidate=60을 선언해두면 하위에 있는 모든 라우팅 페이지에서는 페이지를 60초 간격으로 갱신해 새로 렌더링하게 된다.

```javascript
// app/page.tsx
export const revalidate = 60;
```

캐시와 갱신이 이루어지는 과정은 다음과 같다

1. 최초로 해당 라우트로 요청이 올 때는 미리 정적으로 캐시해 둔 데이터를 보여준다.
2. 캐시된 초기 요청은 revalidate에 선언된 값만큼 유지된다.
3. 만약 해당 시간이 지나도 일단 캐시된 데이터를 보여준다.
4. Next.js는 캐시된 데이터를 보여주는 한편, 시간이 경과했으므로 백그라운드에서 다시 데이터를 불러온다.
5. 4번 작업이 성공적으로 끝나면 캐시된 데이터를 갱신하고, 그렇지 않다면 과거 데이터를 보여준다.

만약 캐시를 전체적으로 무효화하고 싶으면 `router.refresh()`를 사용하면 된다.

### 11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기

과거의 SSR 방식은 페이지를 완전히 렌더링하고 내려줄 때까지 사용자에게 아무것도 보여주지 않았기 때문에 페이지가 완전히 로드되기 전까지 사용자는 빈 페이지만 보게 되었다. 또한 페이지를 받아도 사용자가 상호작용할 수 없는 정적 페이지이며, 사용자가 페이지를 사용할 수 있도록 하이드레이션 과정을 거쳐야 했다.

이를 해결하기 위해 페이지가 완전히 준비될 때까지 기다리지 않고 HTML을 작은 조각으로 쪼개어 클라이언트로 점진적으로 보내는 스트리밍이 도입됐다. 스트리밍을 활용하면 데이터가 로드되는 컴포넌트를 먼저 빠르게 표시하여 페이지의 일부를 사용자에게 보여줄 수 있으며, 이를 통해 사용자는 페이지와 상호작용할 수 있게 됐다. 또한, 스트리밍은 TTFB(Time To First Byte)와 FCP(First Contentful Paint)를 개선하는 데 큰 도움이 되었다.

<br>

## 11.4 웹팩의 대항마, 터보팩의 등장(beta)

Next.js 13에서는 터보팩이 출시되었다. 터보팩은 웹팩에 비해 최대 700배, Vite에 비해 최대 10배 더 빠르며, 러스트로 작성되어 가능한 것이다.
<br>

## 11.5 서버 액션(alpha)

API를 굳이 생성하지 않더라도 함수 수준에서 서버에 직접 접근해 데이터 요청 등을 수행할 수 있는 기능이다. 서버 컴포넌트와 다르게, 특정 함수 실행 그 자체만을 서버에서 수행할 수 있는 장점이 있다.

서버 액션을 만들려면 함수 내부 또는 파일 상단에 클라이언트 선언과 비슷하게 `"use server"`을 선언해야 한다. 그리고 함수는 반드시 `async`여야 한다.

```javascript
async function serverAction() {
  "use server";
  // 서버에 바로 접근하는 코드
}

// 이 파일 내부의 모든 내용이 서버 액션으로 간주된다.
("use server");

export async function myAction() {
  //...
  // 서버에 바로 접근하는 코드
}
```

### 11.5.1 form의 action

`<form/>`은 HTML에서 양식을 보낼 때 사용하는 태그로, action props를 추가해서 이 양식 데이터를 처리할 URI를 넘겨줄 수 있다.

```javascript
async function handleSubmit() {
  "use server";
  const res = await fetch(`https://~`);
}
<form action={handleSubmit}>
  <button>form 요청</button>
</form>;
```

### 11.5.2 input의 submit과 image의 formAction

`form.action`과 마찬가디로 input type='submit' 또는 input type='image'에 formAction prop으로도 서버액션을 추가할 수 있다.

### 11.5.3 startTransition과의 연동

useTranstion에서 제공하는 startTransition에서도 서버 액션을 활용할 수 있다.

```javascript
const [isPending, startTransition] = useTransition();

const handleClick = () => {
  startTransition(() => updateData());
};

return isPending ? <Skeleton /> : <button onClick={handleClick}>reset</button>;
```

useTransition이 반환하는 배열의 두 번째 요소인 startTransition을 사용해 서버 액션을 실행하는 예제를 보여준다. useTransition을 사용하면 얻을 수 있는 장점 중 하나는 이전과 동일한 로직을 구현하면서도 page 단위의 loading.jsx를 사용하지 않아도 된다는 것이다. isPending을 활용해 startTransition으로 서버 액션이 실행됐을 때 해당 버튼을 숨기고 로딩 버튼을 노출함으로써 페이지 단위의 로딩이 아닌 컴포넌트 단위의 로딩 처리도 가능해진다.
이와 동시에 revalidatePath같은 server mutation도 마찬가지로 처리할 수 있다.

### 11.5.4 server mutation이 없는 작업

server mutation이 필요하다면 반드시 서버 액션을 useTransition과 함께 사용해야 하지만 별도의 server mutation을 실행하지 않는다면 **바로 이벤트 핸들러에 넣어도 된다.**

```javascript
export default function Page() {
  async function handleClick() {
    "use server";

    // server mutation이 필요 없는 작업
  }
  return <button onClick={handleClick}>form 요청 보내기</button>;
}
```

### 11.5.5 서버 액션 사용 시 주의할 점

- 서버 액션은 클라이언트 컴포넌트 내에서 정의될 수 없다
- 클라이언트 컴포넌트에서 서버 액션을 사용하고 싶으면 앞의 startTransition 예제처럼 `'use server'`로 서버 액션만 모여있는 파일을 별도로 import해야 한다.
  <br>

## 11.6 그 밖의 변화

<br>

## 11.7 Next.js 13 코드 맛보기

### 11.7.1 getServerSideProps와 비슷한 서버 사이드 렌더링 구현해 보기

### 11.7.2 getStaticProps와 비슷한 정적인 페이지 렌더링 구현해 보기

### 11.7.3 로딩, 스트리밍, 서스펜스

<br>

## 11.8 정리 및 주의사항
