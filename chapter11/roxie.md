# 11장: Next.js 13과 리액트 18

이 장은 Next.js 13과 리액트 18의 새로운 기능을 소개합니다.

<br>

- [11장: Next.js 13과 리액트 18](#11장-nextjs-13과-리액트-18)
  - [11.1 app 디렉터리의 등장](#111-app-디렉터리의-등장)
    - [11.1.1 라우팅](#1111-라우팅)
  - [11.2 리액트 서버 컴포넌트](#112-리액트-서버-컴포넌트)
    - [11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계](#1121-기존-리액트-컴포넌트와-서버-사이드-렌더링의-한계)
    - [11.2.2 서버 컴포넌트란?](#1122-서버-컴포넌트란)
    - [11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이](#1123-서버-사이드-렌더링과-서버-컴포넌트의-차이)
    - [11.2.4 서버 컴포넌트는 어떻게 작동하는가?](#1124-서버-컴포넌트는-어떻게-작동하는가)
  - [11.3 Next.js에서의 리액트 서버 컴포넌트](#113-nextjs에서의-리액트-서버-컴포넌트)
    - [11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitial Props의 삭제](#1131-새로운-fetch-도입과-getserversideprops-getstaticprops-getinitial-props의-삭제)
    - [11.3.2 정적 렌더링과 동적 렌더링](#1132-정적-렌더링과-동적-렌더링)
    - [11.3.3 캐시와 mutating, 그리고 revalidating](#1133-캐시와-mutating-그리고-revalidating)
    - [11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기](#1134-스트리밍을-활용한-점진적인-페이지-불러오기)
  - [11.4 웹팩의 대항마, 터보팩의 등장(beta)](#114-웹팩의-대항마-터보팩의-등장beta)
  - [11.5 서버 액션(alpha)](#115-서버-액션alpha)
    - [11.5.1 form의 action](#1151-form의-action)
    - [11.5.2 input의 submit과 image의 formAction](#1152-input의-submit과-image의-formaction)
    - [11.5.3 startTransition과의 연동](#1153-starttransition과의-연동)
    - [11.5.4 server mutation이 없는 작업](#1154-server-mutation이-없는-작업)
    - [11.5.5 서버 액션 사용 시 주의할 점](#1155-서버-액션-사용-시-주의할-점)
  - [11.6 그 밖의 변화](#116-그-밖의-변화)
  - [11.7 Next.js 13 코드 맛보기](#117-nextjs-13-코드-맛보기)
    - [11.7.1 getServerSideProps와 비슷한 서버 사이드 렌더링 구현해 보기](#1171-getserversideprops와-비슷한-서버-사이드-렌더링-구현해-보기)
    - [11.7.2 getStaticProps와 비슷한 정적인 페이지 렌더링 구현해 보기](#1172-getstaticprops와-비슷한-정적인-페이지-렌더링-구현해-보기)
    - [11.7.3 로딩, 스트리밍, 서스펜스](#1173-로딩-스트리밍-서스펜스)
  - [11.8 정리 및 주의사항](#118-정리-및-주의사항)

<br>

## 11.1 app 디렉터리의 등장

- 13버전 이전의 아쉬웠던 점을 보완해서 릴리스 되었다.
  - 레이아웃 지원
  - 바벨을 대체할 `러스트(Rust)기반 SWC`.
  - 웹팩을 대체할 `Turbopack` 출시.
- Next.js 13에서는 새로운 app 디렉토리가 도입되어 전체 애플리케이션 레이아웃, 라우팅 및 페이지 구성을 더 선언적이고 유연한 방식으로 관리할 수 있게 되었다. 이전에는 pages 디렉토리를 중심으로 구성되었으나, app 디렉토리를 통해 더 세밀한 라우팅 및 레이아웃 제어가 가능해졌다.

### 11.1.1 라우팅

- ` pages` 디렉토리 대신 `app` 디렉토리 내에서 라우팅과 관련된 모든 구성이 이루어진다. 이는 더 직관적인 라우팅 구조와 더 나은 파일 조직을 가능하게 한다.

- app 디렉토리 구조를 살펴보자.

  ```less
  - app/
    - layout.tsx       // 애플리케이션의 메인 레이아웃
    - page.tsx         // 홈페이지
    - dashboard/       // 'Dashboard' 섹션
      - layout.tsx     // Dashboard 섹션의 레이아웃
      - index.tsx      // Dashboard 메인 페이지
      - [id].tsx       // 동적으로 ID에 따라 변하는 페이지
  ```

- 메인 레이아웃 (app/layout.tsx)
  - 애플리케이션의 전체적인 레이아웃을 정의한다. 모든 페이지에 공통적으로 사용될 요소들(헤더, 푸터 등)을 포함할 수 있다.
  ```typescript
  export default function Layout({ children }) {
    return (
      <div>
        <header>헤더 영역</header>
        <main>{children}</main>
        <footer>푸터 영역</footer>
      </div>
    );
  }
  ```
- 홈페이지 (app/page.tsx)
  - page.tsx는 홈페이지를 정의한다. Next.js 13에서는 index.tsx 대신 page.tsx를 사용한다.
  ```typescript
  export default function Page() {
    return <div>홈페이지 내용</div>;
  }
  ```
- 'Dashboard' 섹션 레이아웃 (app/dashboard/layout.tsx)
  - 'Dashboard' 섹션에 특화된 레이아웃을 정의한다. 이 레이아웃은 dashboard 폴더 내의 모든 페이지에 자동으로 적용된다.
  ```typescript
  export default function DashboardLayout({ children }) {
    return (
      <div>
        <nav>대시보드 내비게이션</nav>
        <main>{children}</main>
      </div>
    );
  }
  ```
- 동적 'Dashboard' 페이지 (app/dashboard/[id].tsx)

  - [id].tsx 파일은 동적으로 변하는 'Dashboard' 페이지를 정의한다. 여기서 id는 URL에서 동적으로 결정된다.

  ```typescript
  export default function DashboardItem({ params }) {
    return <div>대시보드 아이템 {params.id} 페이지</div>;
  }

  export async function getServerSideProps({ params }) {
    // 필요한 데이터 패칭 로직
    return { props: { params } };
  }
  ```

<br>

## 11.2 리액트 서버 컴포넌트

### 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 서버 사이드 렌더링은 리액트가 클라이언트 중심으로 돌아가기 때문에 사용자의 인터렉션에 따른 다양한 사용자 경험을 제공하기 어려운 문제들이 발생한다.
- `서버 사이드 렌더링`은 정적 콘텐츠를 빠르게 제공하고, 서버에 있는 데이터에 손쉽게 접근할 수 있는 반면, 사용자의 인터랙션에 따른 다양한 사용자 경험을 제공하기 어렵다. `클라이언트 사이드 렌더링`은 사용자의 인터렉션에 따라 다양한 것들을 제공할 수 있지만, 서버에 비해 느리고 데이터 접근이 어렵다. 이러한 구조의 장점을 모두 취하고자 하는 것이 리액트 서버 컴포넌트다.

### 11.2.2 서버 컴포넌트란?

- 서버에서만 렌더링되며 클라이언트 측 자바스크립트 번들에는 포함되지 않는다.
- 클라이언트 컴포넌트에서 서버 컴포넌트를 불러올 수 없다.
- `서버 컴포넌트`
  - 요청이 오면 서버에서 딱 한번 실행 될 뿐이므로 상태와 생명주기를 가질 수 없다.
  - effect 또는 state에 의존하지 않고 서버에서 제공할 수 있는 기능만 사용하는 훅이라면 사용이 가능하다.
  - 서버에만 있는 데이터를 async/await로 접근할 수 있으며, 컴포넌트 자체가 async한 것이 가능하다.
  - 클라이언트 컴포넌트를 렌더링할 수 있다.
- `클라이언트 컴포넌트`
  - 브라우저 환경에서만 실행되므로 서버 컴포넌트를 불러올 수 없다.(use client ❌)
  - 클라이언트 컴포넌트가 서버 컴포넌트를 자식으로 갖는 구조는 가능하다.
- 공용 컴포넌트
  - 서버 컴포넌트와 클라이언트 컴포넌트의 모든 제약을 받는 컴포넌트다.

### 11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이

- 서버 사이드 렌더링 :
  - `동작 방식` : 서버에서 응답받은 페이지 전체를 HTML로 렌더링한 후 결과를 클라이언트에 전달 하고 클라이언트에서 하이드레이션 과정을 거쳐 서버의 결과물을 확인하고 이벤트를 붙이는 등의 작업을 수행한다.
  - `목적` : 쵝에 인터랙션은 불가능하지만 정적인 HTML을 빠르게 내려주는 데 초점을 두 고 있다.

### 11.2.4 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 렌더링 요청을 받는다.(루트 컴포넌트 == 서버 컴포넌트)
2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화한다. 이때 클라이언트 컴포넌트로 표시된 부분은 플레이스홀더 형식으로 비워두고, 브라우저는 이후에 결과물을 받아서 다시 역직렬화한 다음 렌더링을 수행한다.
3. 브라우저가 리액트 컴포넌트 트리를 구성한다. 클라이언트 컴포넌트를 받았다면 클라이언트에서 렌더링이 진행되고, 서버에서 만들어진 결과물을 받았다면 리액트 트리를 그대로 만들어 최종적으로 이 트리를 렌더링해 브라우저의 DOM에 커밋한다.

<br>

## 11.3 Next.js에서의 리액트 서버 컴포넌트

- 13버전을 릴리스하면서 서버 컴포넌트를 지원하기 시작했다.
- 서버 컴포넌트의 제약
  - 서버 컴포넌트는 클라이언트 컴포넌트를 불러올 수 없으며, 클라이언트 컴포넌트는 서버 컴포넌트를 children props로 받는 것만 가능하다.
  - 루트 컴포넌트는 page.js다. page.js와 layout.js는 반드시 서버 컴포넌트여야 한다.

### 11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitial Props의 삭제

- 과거 서버 사이드 렌더링과 정적 페이지 제공을 위해 이용되던 `getServerSideProps`, `getStaticProps`, `getInitialProps`가 /app 디렉터리 내부에서 삭제됐다.
- 현제 모든 데이터 요청은 웹에 서 제공하는 표준 `API fetch`를 기반으로 이뤄진다.
- 서버 컴포넌트는 데이터가 불러오기 전까지 기다렸다가 데이터가 불러와지면 페이지가 렌더링되어 클라이언트로 전달 된다.
- fetch API를 확장해 같으 서버 컴포넌트 트리 내에서 동일한 요청이 있다면 재요청이 발생하지 않도록 요청 중복을 방지했다.
  - 해달 fetch 요청에 대한 내용을 서버에서는 렌더링이 끝날 때까지 캐싱하며, 클라이언트에서 별도의 지시나 요청이 없는 이상 해당 데이터를 최대한 캐싱해서 중복된 요청을 방지한다.

### 11.3.2 정적 렌더링과 동적 렌더링

- 과거 `getStaticProps` : 서버에서 불러오는 데이터가 변경되지 않는 경우 정적으로 페이지를 만들어 제공할 수 있는 기능.
- 13버전 : 정적인 라우팅은 기본적으로 빌드 타임에 렌더링을 미리 해두고 캐싱해 재 사용할 수 있고, 동적인 라우팅은 서버에 매번 요청이 올때마다 컴포넌트를 렌더링하도로 변경 했다.
- fetch 옵션을 활용하면 기존 `getStaticProps`작동 방식을 흉내 낼수 있고, 요청이 올 때마다 fetch 요청 이후에 렌더링을 수행하게 할수도 있다.

### 11.3.3 캐시와 mutating, 그리고 revalidating

- revalidating :
  ```typescript
  export const revalidate = 60;
  ```
  하위에 있는 모든 라우팅에서 페이지를 60초 간격으로 갱신해 새로 렌더링하게 된다.
  - 캐시와 갱신이 이뤄지는 과정
    1. 최초 라우트 요청이 올 때는 미리 정적으로 캐시해둔 데이터를 보여준다.
    2. 캐시된 초기 요청은 revalidate에 선언된 값만큼 유지된다.
    3. 시간이 경과하면 백그라운드에서 다시 데이터를 불러온다.
    4. 성공적으로 데이터를 불러왔다면, 캐시된 데이터를 갱신하고 그렇지 않다면 과거 데이터를 보여준다.
  - `router.refresh();`를 사용하면 브라우저 히스토리에 영향을 미치지 않고 캐시를 전체적으로 무효화할 수 있다.

### 11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기

- 사용자가 일부라도 페이지와 인터랙션을 할 수 있도로고 페이지가 다 완성될 때까지 기다리는 것이 아니라 HTML을 작은 단위로 쪼개서 완성되는 대로 클라이언트로 점진적으로 보내느 스트리밍이 도입되었다.
- 경로에 loading.tsx를 배치하면 렌더링이 완료되기 전에 보여줄 수 있는 컴포넌트를 배치할 수 있다.

<br>

## 11.4 웹팩의 대항마, 터보팩의 등장(beta)

- 13버전에서 웹팩을 대체할 터보팩(Turbopack)이 출시됐다.
- 터보팩은 웹팩 대비 최대 700배, vite 대비 최대 10배 빠르다고 하며, 러스트 기반으로 작성됐기 때문에 가능하다고 소개하고 있다.
- 현재는 개발 모드에서만 제한적으로 사용 가능하다.

<br>

## 11.5 서버 액션(alpha)

- API를 굳이 생성하지 않더라도 함수 수준에서 서버에 직접 접근해 데이터 요청 등을 수행할 수 있는 기능이다.
- 특정 함수 실행 그 자체만을 서버에서 수행할 수 있다는 장점이 있다.
- 서버 액션 활성화
  ```
  /** @type {import('next').NextConfig} */
  const nextConfig = {
    experimental: {
      serverAction: true,
    }
  }
  module.exports = nextConfig
  ```
- 서버 액션 만들기

  1. `use sever` 지시자를 선언한다.
  2. 함수는 반드시 async여야 한다.

  ```
  async function serverAction(){
    "use server";
    // 서버에 바로 접근하는 코드
  }
  // ============  or ===========
  'use server'

  export async function myAction() {
    // 서버에 바로 접근하는 코드
  }
  ```

### 11.5.1 form의 action

- <form/>은 HTML에서 약식을 보낼 때 사용하는 태그로, action props를 추가해서 이 양식 데이터를 처리할 URI를 넘겨줄 수 있다.
- handleSubmit 이벤트를 발생시키는 것은 클라이언트지만 실제로 함수 자체가 수행되는 것은 서버가 된다.

  ```
  export default function Page() {
    async function handleSubmit() {
      'use server'

      // 해당 작업은 서버에서 수행하며 CORS 이슈가 없다.
      const response = await fetch(url, {options});

      const result = await response.json();
    }
    return (
      <form action={handleSubmit}>
        <button type="submit">form 요청 보내기</button>
      </form>
    )
  }
  ```

  - 서버 액션을 실행하면 클라이언트에서 현재 라우트 주소와 ACTION_ID만 보내고 그 이외 아무것도 실행하지 않는 것을 알 수 있다.
  - 서버에서는 요청 받은 라우트 주소와 ACTION_ID를 바탕으로 실행해야 할 내용을 찾아 실행 한다.
  - 'use server'로 선언돼 있는 내용을 빌드 시점에 미리 클라이언트에서 분리시켜 서버로 옮김으로써 클라이언트 번들링 결과물에는 포함되지 않고 서버에서만 실행되는 서버 액션을 만든 것을 확인 할 수 있다.

- form과 실제 노출하는 데이터가 연됭돼 있으 ㄹ때 더욱 효과적으로 사용할 수 있다.
- 새로고침 없이 수정된 결과를 다시금 조회해서 새로운 결과로 렌더링할 수 있다.
- 인수로 넘겨받은 경로릐 캐시를 초기화해서 해당 URL에서 즉시 새로운 데이터를 불러오는 역할을 server mutation(서버에서의 데이터 수정)이라고 한다.
  - `redirect`: next/navigation으로 특정 주소로 리타이렉트 할 수 있다.
  - `revalidatePath`: next/cache로 해당 주소의 캐시를 즉시 업데이트한다.
  - `revalidateTag`: naxt/cache로 fetch 요청 시에 추가할 수 있다..

### 11.5.2 input의 submit과 image의 formAction

### 11.5.3 startTransition과의 연동

- useTransition에서 제공하는 startTransition에서도 서버 액션을 활용할 수 있다.
- 이전과 동일한 로직을 구현하면서도 page 단위의 loading.jsx를 사용하지 않아도 된다. isPending을 활용해 startTransition으로 서버 액션이 실행됐을 경우 페이지 단위의 로딩이 아닌 컴포넌트 단위의 로딩 처리도 가능하다.

### 11.5.4 server mutation이 없는 작업

- server mutation이 필요하다면 반드시 서버 액션을 useTransition과 함께 사용한다.

### 11.5.5 서버 액션 사용 시 주의할 점

- 클라이언트 컴포넌트 내에서 정의될 수 없다.
- 별도 'use server'로 서버 액션만 모여 있는 파일을 별로도 임포트해야 한다.

<br>

## 11.6 그 밖의 변화

- 미들웨어 강화
- 손쉬운 SEO 작성
- 정적 내부 링크 분석 기능

<br>

## 11.7 Next.js 13 코드 맛보기

### 11.7.1 getServerSideProps와 비슷한 서버 사이드 렌더링 구현해 보기

### 11.7.2 getStaticProps와 비슷한 정적인 페이지 렌더링 구현해 보기

### 11.7.3 로딩, 스트리밍, 서스펜스

- 컴포넌트가 렌더링 중이라는 것을 나타낼 수 있다.
- loading과 suspense 모두 동일한 방식으로 작동하며, suspense가 조금 더 개발자가 원하는 형태로 쪼개서 보여줄 수 있다.
  <br>

## 11.8 정리 및 주의사항
